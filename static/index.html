<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>QR Code File Transfer</title>
    <script src="/vendor/qrcode.min.js"></script>
    <script src="https://jimmywarting.github.io/StreamSaver.js/StreamSaver.js?version=2.0.0"></script>
  </head>
  <body>
    <div id="output"></div>
    <form>
      <input id="input" style="width: 500px;" />
      <input id="hidden-dummy-input" style="display: none;" />
      <input type="submit" />
    </form>

    <script type="module">
    import {
      textEncoder, textDecoder, base64ToBytes, bytesToBase64, readAll,
    } from '/util.mjs';
    import { DH } from '/crypto.mjs';
    import { Host, Relay } from '/api.mjs';
    import { ControlSocket } from '/main.mjs';

    (async () => {
      const input = document.getElementById('input');
      const hiddenDummyInput = document.getElementById('hidden-dummy-input');
      const output = document.getElementById('output');

      document.forms[0].addEventListener('submit', (e) => {
        e.preventDefault();
      });

      const dh = new DH();

      async function listen() {
        const hid = await Host.open();

        const pw = btoa([...window.crypto.getRandomValues(new Uint8Array(24))].map((x) => String.fromCharCode(x)));

        const href = `${window.location.origin}/?hid=${encodeURIComponent(hid)}&pubkey=${bytesToBase64(await dh.publicKey)}`;
        const div = document.createElement('p');
        const link = document.createElement('a');
        link.href = href;
        link.innerText = 'connect';
        div.appendChild(link);
        output.appendChild(div);

        const qrcode = document.createElement('p');
        new QRCode(qrcode, href);
        output.appendChild(qrcode);

        try {
          for (;;) {
            const d = await Host.accept(hid);

            if (d.ok) {
              return {
                loc: d.location,
                pk: base64ToBytes(d.message),
              };
            }
          }
        } catch (e) {
          switch (e.status) {
          case 404:
            break;
          default:
            throw e;
          }
        } finally {
          try {
            await Host.close(hid);
          } catch (e) {}
        }
      }

      const { loc, pk } = await (async () => {
        const qm = new Map(window.location.search.substring(1).
          split('&').map((x) => {
            const i = x.indexOf('=');
            if (i === -1) return [x];
            return [x.substring(0, i), decodeURIComponent(x.substring(i + 1))];
          }));

        if (qm.has('hid')) {
          const hid = qm.get('hid');
          const loc = await Host.connect(hid, bytesToBase64(await dh.publicKey));
          return {
            loc,
            pk: base64ToBytes(qm.get('pubkey')),
          };
        }

        return listen();
      })();

      await Relay.open(loc);

      const s = new ControlSocket(loc, dh, pk);
      await s.start();

      input.focus();

      document.forms[0].addEventListener('submit', async () => {
        if (!loc) return;

        const msg = input.value;
        hiddenDummyInput.focus();
        input.focus();
        input.value = '';

        const { readable, writable } = new TransformStream();
        const { fileSent, checksumSent } = await s.sendFile({}, readable);
        const w = writable.getWriter();
        w.write(textEncoder.encode(msg));
        w.close();
        await Promise.all([fileSent, checksumSent]);
      });

      for (;;) {
        const { readable } = await s.recvFile();
        const b = await readAll(readable);
        const msg = textDecoder.decode(b);

        const text = document.createElement('p');
        text.innerText = msg;
        output.appendChild(text);
      }
    })();
    </script>
  </body>
</html>
